# CyberSecurity-CVE-Vulnerability-Query-Assistant
CVE Vulnerability Query Assistant


# üõ°Ô∏è CVE Vulnerability Query Assistant

This Python project allows users to query CVE (Common Vulnerabilities and Exposures) data using natural language, powered by **LangChain + Ollama** and executed on a **MySQL** backend. It features both **CLI** and **Web** interfaces.

---

## üöÄ Features

### üîó LangChain + Ollama Integration
- Uses [LangChain](https://www.langchain.com/) with a local LLM (e.g., Mistral via [Ollama](https://ollama.com/)).
- Converts natural language questions into secure SQL queries.
- Prompt is tuned specifically for CVE-related database queries.

### üóÉÔ∏è MySQL Backend
- Connects to a MySQL database with the following table structure:

```sql
CREATE TABLE cve_data (
    id INT,
    cve_id VARCHAR(255),
    description TEXT,
    published_date DATE,
    severity VARCHAR(20), -- LOW, MEDIUM, HIGH, CRITICAL
    score FLOAT,
    affected_products TEXT
);
```

### ‚úÖ Query Validation
- Only `SELECT` queries are allowed.
- Automatically detects and blocks invalid SQL queries.

### üì¶ Output Export
- Results are exported to:
  - `cve_results.csv`
  - `cve_results.json`
- Exports happen both in CLI and web modes.

### Create Script 
create script cve_assistant.py

```bash
from langchain.chat_models import ChatOllama
from langchain.prompts import ChatPromptTemplate
from langchain.chains import LLMChain
import mysql.connector
import re
import sys
import csv
import json
import logging
from flask import Flask, request, jsonify, render_template_string

# Initialize logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Step 1: Initialize LangChain with Ollama
llm = ChatOllama(model="mistral")  # Replace with your model name if different

# Step 2: Define a CVE-specific prompt template for generating SQL
cve_sql_prompt = ChatPromptTemplate.from_template("""
You are an expert SQL assistant for CVE (Common Vulnerabilities and Exposures) data.
Given a user's request, convert it into a SQL query for a MySQL database that has this schema:

Table: cve_data
Columns:
- id (INT)
- cve_id (VARCHAR)
- description (TEXT)
- published_date (DATE)
- severity (VARCHAR: LOW, MEDIUM, HIGH, CRITICAL)
- score (FLOAT)
- affected_products (TEXT)

Important guidelines:
- Always filter by published_date if the user mentions time (e.g., "last 30 days").
- Use severity and score intelligently based on risk-level terms (e.g., "critical" = severity='CRITICAL').
- If the user asks for affected software, use the affected_products column.
- Return only valid SQL SELECT statements.

User Request: {user_request}
Return only the SQL query.
""")

# Step 3: Define LLM chain to convert natural language to SQL
cve_query_chain = LLMChain(prompt=cve_sql_prompt, llm=llm)

# Step 4: Execute SQL query against MySQL database
def run_sql_query(query: str):
    if not re.match(r"^SELECT ", query.strip(), re.IGNORECASE):
        return [], [["Only SELECT queries are allowed."]]

    try:
        conn = mysql.connector.connect(
            host="localhost",  # Replace with your Kubernetes service name or external IP
            user="youruser",
            password="yourpassword",
            database="cve_db"
        )
        cursor = conn.cursor()
        cursor.execute(query)
        columns = [col[0] for col in cursor.description]
        results = cursor.fetchall()
        conn.close()
        return columns, results
    except mysql.connector.Error as err:
        logging.error(f"Database error: {err}")
        return [], [[f"Database error: {err}"]]

# Export to CSV
def export_to_csv(columns, rows, filename="cve_results.csv"):
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(columns)
        writer.writerows(rows)
    logging.info(f"Results exported to {filename}")

# Export to JSON
def export_to_json(columns, rows, filename="cve_results.json"):
    data = [dict(zip(columns, row)) for row in rows]
    with open(filename, 'w') as file:
        json.dump(data, file, indent=2)
    logging.info(f"Results exported to {filename}")

# Step 5: CLI Frontend for User Interaction
def cli_interface():
    print("\nüõ°Ô∏è  CVE Vulnerability Query Assistant (CLI Mode) üõ°Ô∏è\n")
    user_request = input("Enter your question about CVEs: ")

    sql_query = cve_query_chain.run(user_request)
    print("\nüß† Generated SQL Query:\n", sql_query)
    columns, rows = run_sql_query(sql_query)

    print("\nüìä Query Results:")
    if columns and rows:
        print(" | ".join(columns))
        for row in rows:
            print(" | ".join(str(cell) for cell in row))

        export_to_csv(columns, rows)
        export_to_json(columns, rows)
    else:
        print("No results found or query was invalid.")

# Step 6: Web Frontend using Flask
app = Flask(__name__)

@app.route("/", methods=["GET", "POST"])
def home():
    result = None
    query = ""
    if request.method == "POST":
        query = request.form.get("query")
        sql_query = cve_query_chain.run(query)
        columns, rows = run_sql_query(sql_query)
        result = {"columns": columns, "rows": rows, "sql": sql_query}
        export_to_csv(columns, rows, "web_cve_results.csv")
        export_to_json(columns, rows, "web_cve_results.json")
    return render_template_string('''
        <h2>CVE Vulnerability Query Assistant</h2>
        <form method="post">
            <textarea name="query" rows="4" cols="60" placeholder="Enter your CVE question">{{ query }}</textarea><br>
            <input type="submit" value="Run Query">
        </form>
        {% if result %}
            <h3>Generated SQL</h3>
            <pre>{{ result.sql }}</pre>
            <h3>Results</h3>
            <table border="1">
                <tr>{% for col in result.columns %}<th>{{ col }}</th>{% endfor %}</tr>
                {% for row in result.rows %}<tr>{% for cell in row %}<td>{{ cell }}</td>{% endfor %}</tr>{% endfor %}
            </table>
        {% endif %}
    ''', result=result, query=query)

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "cli":
        cli_interface()
    else:
        app.run(debug=True, port=5000)  # Access via http://localhost:5000

```

### üßë‚Äçüíª CLI Mode

Run the tool from terminal:

```bash
python cve_assistant.py cli
```

You can ask things like:
- ‚ÄúList critical vulnerabilities in the last 30 days‚Äù
- ‚ÄúWhat CVEs affect Apache and have a score above 7?‚Äù

### üåê Web Mode (Flask)

Launch a lightweight web interface:

```bash
python cve_assistant.py
```

Then open: [http://localhost:5000](http://localhost:5000)

- Input a query
- See the generated SQL
- View results in a table
- Exports automatically created

### üßæ Logging

Logs all key events including:
- Query attempts
- Errors (e.g., DB connection)
- Export status

Logs are printed to the console using `logging.INFO`.

---

## üõ†Ô∏è Tech Stack

- **Python**
- **LangChain**
- **Ollama (LLM backend, e.g., Mistral)**
- **MySQL**
- **Flask** (for the web interface)

---

## üìå Example Use Cases

| Natural Language Input                          | SQL Behavior                                   |
|-------------------------------------------------|------------------------------------------------|
| `Critical CVEs from last 30 days`               | Filters by `published_date` + `severity`       |
| `CVEs affecting Apache`                         | Filters by `affected_products LIKE '%Apache%'` |
| `High severity CVEs with score above 7`         | Filters by `severity` and `score`              |

---

## üîÑ Future Improvements

- Dockerize for deployment on Kubernetes
- Add authentication to the web UI
- Add charts, graphs, and filters
- Real-time CVE sync from NVD or other feeds
